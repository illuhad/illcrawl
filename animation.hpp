/*
 * This file is part of illcrawl, a reconstruction engine for data from
 * the illustris simulation.
 *
 * Copyright (C) 2017  Aksel Alpay
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */


#ifndef ANIMATION
#define ANIMATION

#include <functional>
#include <cassert>
#include <boost/mpi.hpp>
#include <cmath>

#include "math.hpp"
#include "camera.hpp"
#include "volumetric_reconstruction.hpp"
#include "quantity.hpp"

namespace illcrawl {

/// Given a \c camera_stepper object which moves the camera
/// and a \c frame_renderer object which generates the frames,
/// the \c animation class renders a frame for each camera position
/// (and look-at direction) generated by the \c camera_stepper.
/// Each frame is stored as a slice in 3D data cube.
class animation
{
public:
  /// A frame renderer renders a frame at a given camera position.
  /// \param cam The camera position
  /// \param frame_id The id (0 to \c num_frames - 1) of the current frame
  /// \param num_frames The total number of frames that shall be rendered
  /// \param out The \c frame_renderer shall write the new frame into this 2D array.
  /// It is the responsibility of the \c frame_renderer to properly intialize the
  /// array dimension/sizes.
  using frame_renderer = std::function
  <
    void (const camera& cam,
          std::size_t frame_id,
          std::size_t num_frames,
          util::multi_array<device_scalar>& out)
  >;
  /// The \c camera_stepper advances the camera position and look-at vector after
  /// each frame.
  /// \param frame_id The id (0 to \c num_frames - 1) of the current frame
  /// \param num_frames The total number of frames that shall be rendered
  /// \param cam The camera object which the state shall be advanced by
  /// the \c camera_stepper.
  using camera_stepper = std::function
  <
    void (std::size_t frame_id, std::size_t num_frames, camera& cam)
  >;

  /// Construct object
  /// \param renderer The \c frame_renderer which will be used to generate each
  /// individual frame.
  /// \param stepper The \c camera_stepper that will be used to update the
  /// camera's position and
  /// look-at vector after every frame.
  /// \param initial_camera The initial camera state
  animation(const frame_renderer& renderer,
            const camera_stepper& stepper,
            const camera& initial_camera)
    : _renderer{renderer},
      _stepper{stepper},
      _cam{initial_camera}
  {}

  virtual ~animation(){}

  /// Renders the animation
  /// \param num_frames The total number of frames that shall be rendered. Note that
  /// increasing \c num_frames (depending on the \c camera_stepper) typically does not
  /// increase the rendered 'time' range, but instead only increases the resolution of the
  /// animation.
  /// \param out An array to hold the result of the animation. This array does not yet need
  /// to initialized; it will be properly initialized by this function.
  virtual void operator()(std::size_t num_frames, util::multi_array<device_scalar>& out)
  {
    (*this)(0, num_frames, num_frames, out);
  }



protected:
  /// \param first_frame The first frame of the frame range that should be
  /// renderered
  /// \param end_frame The frame after the last frame to be rendered
  /// \param total_frame_range The total number of frames that should be rendered
  /// \param out The output, with each frame being a slice along the z-Axis of the
  /// multi array.
  void operator()(std::size_t first_frame,
                  std::size_t end_frame,
                  std::size_t total_frame_range,
                  util::multi_array<device_scalar>& out)
  {
    if(first_frame == end_frame)
      return;

    assert(end_frame > first_frame);

    out = util::multi_array<device_scalar>{
        _cam.get_num_pixels(0),
        _cam.get_num_pixels(1),
        end_frame - first_frame
    };

    util::multi_array<device_scalar> frame;
    for(std::size_t i = first_frame; i < end_frame; ++i)
    {
      _stepper(i, total_frame_range, _cam);
      _renderer(_cam, i, total_frame_range, frame);

      assert(frame.get_extent_of_dimension(0) == _cam.get_num_pixels(0));
      assert(frame.get_extent_of_dimension(1) == _cam.get_num_pixels(1));

      // Copy rendered frame to result cube
      for(std::size_t y = 0; y < _cam.get_num_pixels(1); ++y)
        for(std::size_t x = 0; x < _cam.get_num_pixels(0); ++x)
        {
          std::size_t idx2 [] = {x,y};
          std::size_t idx3 [] = {x,y, i - first_frame};
          out[idx3] = frame[idx2];
        }
    }
  }

private:

  frame_renderer _renderer;
  camera_stepper _stepper;
  camera _cam;

};


/// Like \c animation, but parallelized for distributed memory systems.
/// The parallelization is done by partitioning the frames to render
/// across the parallel processes, such that each process only
/// needs to compute a subset of the overall animation.
/// \tparam Partitioner The type of the partitioner that will
/// be used to partition the work. Must fulfill the partitioner concept
/// -- see the implementation of \c uniform_work_partitioner for an
/// example.
template<class Partitioner>
class distributed_animation : public animation
{
public:
  /// Construct object
  /// \param partitioner The partitioner that will be used assigns
  /// subsets of the work to the individual parallel processes.
  /// \param renderer The \c frame_renderer which will be used to generate each individual frame.
  /// \param stepper The \c camera_stepper that will be used to update the camera's position and
  /// look-at vector after every frame.
  /// \param initial_camera The initial camera state
  distributed_animation(const Partitioner& partitioner,
                        const frame_renderer& renderer,
                        const camera_stepper& stepper,
                        const camera& initial_camera)
    : animation{renderer, stepper, initial_camera},
      _partitioner{partitioner}
  {}

  /// Renders the animation
  /// \param num_frames the total (global) number of frames to render
  /// \param local_result A 3d array containing the rendered frames of the animation that were
  /// assigned to this process. The overall result is distributed across the memory of all parallel
  /// processes. It is the responsibility of the user to gather all local results, if this is required.
  virtual void operator()(std::size_t num_frames,
                          util::multi_array<device_scalar>& local_result) override
  {
    _partitioner.run(num_frames);

    animation::operator ()(_partitioner.own_begin(), _partitioner.own_end(), num_frames, local_result);
  }

  virtual ~distributed_animation(){}

  /// \return The partitioner that has been used to distribute the work, and holds
  /// the information which frames of the animation this process has rendered.
  const Partitioner& get_partitioning() const
  {
    return _partitioner;
  }
private:
  Partitioner _partitioner;
};

namespace camera_movement {

/// Satisifies the \c animation::camera_stepper concept and implements
/// a rotation of the camera around one point.
class rotation_around_point
{
public:
  /// A function object that returns a rotation matrix given a rotation angle.
  /// \param alpha The rotation angle in rad.
  using rotation_matrix_creator = std::function<math::matrix3x3 (math::scalar alpha)>;

  /// \param center The center of the rotation
  /// \param cam The initial state of the camera
  /// \param matrix_creator A function that will be
  /// used to generate the rotation matrix for the rotation
  /// \param rotation_range_degree The range of the rotaton in degree.
  rotation_around_point(const math::vector3& center,
                        const camera& cam,
                        rotation_matrix_creator matrix_creator,
                        math::scalar rotation_range_degree = 360.0)
    : _rotation_center(center),
      _rotation_range{(2.0 * M_PI / 360.0) * rotation_range_degree},
      _initial_camera{cam},
      _rotation_creator{matrix_creator}
  {
  }

  /// \param center The center of the rotation
  /// \param axis The rotation axis (must be a normalized vector)
  /// \param cam The initial state of the camera
  /// \param rotation_range_degree The range of the rotaton in degree.
  rotation_around_point(const math::vector3& center,
                        const math::vector3& axis,
                        const camera& cam,
                        math::scalar rotation_range_degree = 360.0)
    : _rotation_center(center),
      _rotation_range{(2.0 * M_PI / 360.0) * rotation_range_degree},
      _initial_camera{cam}
  {
    _rotation_creator = [axis](math::scalar alpha) -> math::matrix3x3
    {
      math::matrix3x3 rotation;
      math::matrix_create_rotation_matrix(&rotation,
                                          axis,
                                          alpha);
      return rotation;
    };
  }

  /// Rotate the camera position and look-at vector
  /// \param frame_id The id of the frame of which the rotation state shall be adopted
  /// If \c frame_id = 0, the rotation angle is 0 rad, if \c frame_id = \c num_frames - 1
  /// the rotation angle is \c _rotation_range.
  /// \param num_frames The total number of frames
  /// \param cam the camera object that shall be rotated
  void operator()(std::size_t frame_id, std::size_t num_frames, camera& cam) const
  {
    math::scalar angle_per_frame = _rotation_range / static_cast<math::scalar>(num_frames);

    math::matrix3x3 rotation_matrix = _rotation_creator(frame_id * angle_per_frame);

    // Reset camera to initial animation state
    cam = _initial_camera;
    // Now apply rotation to current state
    cam.rotate(rotation_matrix, _rotation_center);
  }

  /// Sets the function that is used to generate the rotation matrix.
  void set_rotation_matrix_creator(rotation_matrix_creator creator)
  {
    _rotation_creator = creator;
  }

private:
  math::vector3 _rotation_center;

  const math::scalar _rotation_range;
  const camera _initial_camera;

  rotation_matrix_creator _rotation_creator;
};

/// Satisifies the \c animation::camera_stepper concept and implements
/// a rotation of the camera around one point and around two axes, described
/// by the angles phi and theta.
class dual_axis_rotation_around_point
{
public:
  /// \param center The center of the rotation
  /// \param phi_axis A normalized vector corresponding to the
  /// rotation axis of the phi angle
  /// \param theta_axis A normalized vector corresponding to the
  /// rotation axis of the theta angle
  /// \param cam The initial state of the camera
  /// \param rotation_range_phi_degree The range of the phi rotation in degree
  /// \param rotation_range_theta_degree The range of the theta rotation in degree
  dual_axis_rotation_around_point(const math::vector3& center,
                                   const math::vector3& phi_axis,
                                   const math::vector3& theta_axis,
                                   const camera& cam,
                                   math::scalar rotation_range_phi_degree = 360.0,
                                   math::scalar rotation_range_theta_degree = 360.0)
  : _rotation{center, phi_axis, cam, rotation_range_phi_degree}
  {
    auto rotation_creator =
    [phi_axis, theta_axis, rotation_range_phi_degree, rotation_range_theta_degree](math::scalar alpha_phi)
    {
      math::scalar alpha_theta = alpha_phi * (rotation_range_theta_degree / rotation_range_phi_degree);
      return generate_rotation_matrix(alpha_phi, alpha_theta, phi_axis, theta_axis);
    };

    _rotation.set_rotation_matrix_creator(rotation_creator);
  }

  /// Rotate the camera position and look-at vector
  /// \param frame_id The id of the frame of which the rotation state shall be adopted
  /// If \c frame_id = 0, the rotation angle is 0 rad, if \c frame_id = \c num_frames - 1
  /// the rotation angle is \c _rotation_range.
  /// \param num_frames The total number of frames
  /// \param cam the camera object that shall be rotated
  void operator()(std::size_t frame_id, std::size_t num_frames, camera& cam)
  {
    _rotation(frame_id, num_frames, cam);
  }

private:
  /// generate a matrix for the rotation around two axes.
  /// \param alpha_phi The phi angle in rad
  /// \param alpha_theta The theta angle in rad
  /// \param phi_axis The phi axis (must be normalized!)
  /// \param theta_axis The theta axis (must be normalized!)
  static math::matrix3x3 generate_rotation_matrix(math::scalar alpha_phi,
                                                  math::scalar alpha_theta,
                                                  const math::vector3& phi_axis,
                                                  const math::vector3& theta_axis)
  {
    math::matrix3x3 M_phi, M_theta;
    math::matrix_create_rotation_matrix(&M_phi, phi_axis, alpha_phi);
    math::matrix_create_rotation_matrix(&M_theta, theta_axis, alpha_theta);

    return math::matrix_matrix_mult(M_phi, M_theta);
  }

  rotation_around_point _rotation;
};

/// A camera stepper that does not modify the camera at all
/// (useful for animations where the camera should stand still,
/// and quantity parameters shall be modified instead)
class constant_state
{
public:
  /// \c operator() to satisfy the \c camera_stepper concept. This camera stepper
  /// will not do anything.
  /// \param frame_id The id of the current frame
  /// \param num_frames The total number of frames
  /// \param cam The camera
  void operator()(std::size_t frame_id, std::size_t num_frames, camera& cam)
  {}
};

} // camera_movement

namespace frame_rendering {

/// Satisifies the \c animation::frame_renderer concept. An implementation
/// of a \c frame_renderer that renders images using the \c volumetric_integration,
/// i.e. an image is rendered by integrating through the reconstruction of a quantity.
template<class Volumetric_reconstructor,
         class Integration_tolerance_type>
class integrated_projection
{
public:
  /// \param ctx The OpenCL context that shall be used during the rendering process
  /// \param reconstructed_quantity The quantity that is reconstructed
  /// \param integration_depth The range of the integration
  /// \param tol The tolerance of the integration
  /// \param reconstructor The reconstruction engine that shall be used.
  integrated_projection(const qcl::device_context_ptr& ctx,
              const reconstruction_quantity::quantity& reconstructed_quantity,
              math::scalar integration_depth,
              const Integration_tolerance_type& tol,
              Volumetric_reconstructor& reconstructor)
    : _ctx{ctx},
      _reconstructed_quantity{reconstructed_quantity},
      _integration_range{integration_depth},
      _tolerance{tol},
      _reconstructor{reconstructor}
  {
    assert(_ctx != nullptr);
  }

  /// Renders a frame
  /// \param cam The camera object describing position, look-at, resolution etc of
  /// the pixel screen
  /// \param frame_id The id (0 to \c num_frames - 1) of the current frame
  /// \param num_frames The total number of frames that shall be rendered
  /// \param out An array to hold the result. \c out will be properly initialized
  /// by this function, and does not need to be preinitialized.
  void operator()(const camera& cam,
                  std::size_t frame_id,
                  std::size_t num_frames,
                  util::multi_array<device_scalar>& out)
  {
    volumetric_integration<Volumetric_reconstructor> integrator{_ctx, cam};

    integrator.create_projection(_reconstructor,
                                 _reconstructed_quantity,
                                 _integration_range,
                                 _tolerance,
                                 out);
  }

private:
  qcl::device_context_ptr _ctx;
  const reconstruction_quantity::quantity& _reconstructed_quantity;

  math::scalar _integration_range;
  Integration_tolerance_type _tolerance;

  Volumetric_reconstructor _reconstructor;
};

template<class Volumetric_reconstructor,
         class Integration_tolerance_type>
class multi_quantity_integrated_projection
{
public:
  using quantity_ptr = std::shared_ptr<reconstruction_quantity::quantity>;
  using quantity_generator = std::function
  <
    quantity_ptr (const camera& cam, std::size_t frame_id, std::size_t num_frames)
  >;

  multi_quantity_integrated_projection(const qcl::device_context_ptr& ctx,
                                       math::scalar integration_depth,
                                       const Integration_tolerance_type& tol,
                                       Volumetric_reconstructor& reconstructor,
                                       const quantity_generator& create_quantity)
    : _ctx{ctx},
      _integration_range{integration_depth},
      _tolerance{tol},
      _reconstructor{reconstructor},
      _create_quantity{create_quantity}
  {
    assert(_ctx != nullptr);
  }



  void operator()(const camera& cam,
                  std::size_t frame_id,
                  std::size_t num_frames,
                  util::multi_array<device_scalar>& out)
  {
    // This is a workaround to force the reconstructors to recalculate
    // the quantities - otherwise the reconstructor will assume that
    // nothing has changed and reuse the previous state.
    _reconstructor.purge_state();

    volumetric_integration<Volumetric_reconstructor> integrator{_ctx, cam};

    integrator.create_projection(_reconstructor,
                                 *_create_quantity(cam, frame_id, num_frames),
                                 _integration_range,
                                 _tolerance,
                                 out);
  }

private:
  qcl::device_context_ptr _ctx;
  math::scalar _integration_range;
  Integration_tolerance_type _tolerance;
  Volumetric_reconstructor _reconstructor;
  quantity_generator _create_quantity;
};


class single_quantity_generator
{
public:
  single_quantity_generator(const std::shared_ptr<reconstruction_quantity::quantity>& q)
    : _quantity{q}
  {}

  std::shared_ptr<reconstruction_quantity::quantity> operator()(const camera& cam,
                                                      std::size_t frame_id,
                                                      std::size_t num_frames) const
  {
    return _quantity;
  }
private:
  std::shared_ptr<reconstruction_quantity::quantity> _quantity;
};




}
}

#endif

