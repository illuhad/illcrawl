/*
 * This file is part of illcrawl, a reconstruction engine for data from
 * the illustris simulation.
 *
 * Copyright (C) 2017  Aksel Alpay
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */


#ifndef ANIMATION
#define ANIMATION

#include <functional>
#include <cassert>
#include <boost/mpi.hpp>
#include <cmath>

#include "math.hpp"
#include "camera.hpp"
#include "reconstructing_data_crawler.hpp"
#include "quantity.hpp"
#include "work_partitioner.hpp"
#include "multi_array.hpp"
#include "integration.hpp"

namespace illcrawl {

/// Given a \c camera_stepper object which moves the camera
/// and a \c frame_renderer object which generates the frames,
/// the \c animation class renders a frame for each camera position
/// (and look-at direction) generated by the \c camera_stepper.
/// Each frame is stored as a slice in 3D data cube.
class animation
{
public:
  /// A frame renderer renders a frame at a given camera position.
  /// \param cam The camera position
  /// \param frame_id The id (0 to \c num_frames - 1) of the current frame
  /// \param num_frames The total number of frames that shall be rendered
  /// \param out The \c frame_renderer shall write the new frame into this 2D array.
  /// It is the responsibility of the \c frame_renderer to properly intialize the
  /// array dimension/sizes.
  using frame_renderer = std::function
  <
    void (const camera& cam,
          std::size_t frame_id,
          std::size_t num_frames,
          util::multi_array<device_scalar>& out)
  >;
  /// The \c camera_stepper advances the camera position and look-at vector after
  /// each frame.
  /// \param frame_id The id (0 to \c num_frames - 1) of the current frame
  /// \param num_frames The total number of frames that shall be rendered
  /// \param cam The camera object which the state shall be advanced by
  /// the \c camera_stepper.
  using camera_stepper = std::function
  <
    void (std::size_t frame_id, std::size_t num_frames, camera& cam)
  >;

  /// Construct object
  /// \param renderer The \c frame_renderer which will be used to generate each
  /// individual frame.
  /// \param stepper The \c camera_stepper that will be used to update the
  /// camera's position and
  /// look-at vector after every frame.
  /// \param initial_camera The initial camera state
  animation(const frame_renderer& renderer,
            const camera_stepper& stepper,
            const camera& initial_camera);

  virtual ~animation(){}

  /// Renders the animation
  /// \param num_frames The total number of frames that shall be rendered. Note that
  /// increasing \c num_frames (depending on the \c camera_stepper) typically does not
  /// increase the rendered 'time' range, but instead only increases the resolution of the
  /// animation.
  /// \param out An array to hold the result of the animation. This array does not yet need
  /// to initialized; it will be properly initialized by this function.
  virtual void operator()(std::size_t num_frames, util::multi_array<device_scalar>& out);

protected:
  /// \param first_frame The first frame of the frame range that should be
  /// renderered
  /// \param end_frame The frame after the last frame to be rendered
  /// \param total_frame_range The total number of frames that should be rendered
  /// \param out The output, with each frame being a slice along the z-Axis of the
  /// multi array.
  void operator()(std::size_t first_frame,
                  std::size_t end_frame,
                  std::size_t total_frame_range,
                  util::multi_array<device_scalar>& out);

private:

  frame_renderer _renderer;
  camera_stepper _stepper;
  camera _cam;

};


/// Like \c animation, but parallelized for distributed memory systems.
/// The parallelization is done by partitioning the frames to render
/// across the parallel processes, such that each process only
/// needs to compute a subset of the overall animation.
class distributed_animation : public animation
{
public:
  /// Construct object
  /// \param partitioner The partitioner that will be used assigns
  /// subsets of the work to the individual parallel processes.
  /// \param renderer The \c frame_renderer which will be used to generate each individual frame.
  /// \param stepper The \c camera_stepper that will be used to update the camera's position and
  /// look-at vector after every frame.
  /// \param initial_camera The initial camera state
  distributed_animation(const work_partitioner& partitioner,
                        const frame_renderer& renderer,
                        const camera_stepper& stepper,
                        const camera& initial_camera);

  /// Renders the animation
  /// \param num_frames the total (global) number of frames to render
  /// \param local_result A 3d array containing the rendered frames of the animation that were
  /// assigned to this process. The overall result is distributed across the memory of all parallel
  /// processes. It is the responsibility of the user to gather all local results, if this is required.
  virtual void operator()(std::size_t num_frames,
                          util::multi_array<device_scalar>& local_result) override;

  virtual ~distributed_animation(){}

  /// \return The partitioner that has been used to distribute the work, and holds
  /// the information which frames of the animation this process has rendered.
  const work_partitioner& get_partitioning() const;
private:
  std::unique_ptr<work_partitioner> _partitioner;
};

namespace camera_movement {

/// Satisifies the \c animation::camera_stepper concept and implements
/// a rotation of the camera around one point.
class rotation_around_point
{
public:
  /// A function object that returns a rotation matrix given a rotation angle.
  /// \param alpha The rotation angle in rad.
  using rotation_matrix_creator = std::function<math::matrix3x3 (math::scalar alpha)>;

  /// \param center The center of the rotation
  /// \param cam The initial state of the camera
  /// \param matrix_creator A function that will be
  /// used to generate the rotation matrix for the rotation
  /// \param rotation_range_degree The range of the rotaton in degree.
  rotation_around_point(const math::vector3& center,
                        const camera& cam,
                        rotation_matrix_creator matrix_creator,
                        math::scalar rotation_range_degree = 360.0);

  /// \param center The center of the rotation
  /// \param axis The rotation axis (must be a normalized vector)
  /// \param cam The initial state of the camera
  /// \param rotation_range_degree The range of the rotaton in degree.
  rotation_around_point(const math::vector3& center,
                        const math::vector3& axis,
                        const camera& cam,
                        math::scalar rotation_range_degree = 360.0);

  /// Rotate the camera position and look-at vector
  /// \param frame_id The id of the frame of which the rotation state shall be adopted
  /// If \c frame_id = 0, the rotation angle is 0 rad, if \c frame_id = \c num_frames - 1
  /// the rotation angle is \c _rotation_range.
  /// \param num_frames The total number of frames
  /// \param cam the camera object that shall be rotated
  void operator()(std::size_t frame_id, std::size_t num_frames, camera& cam) const;

  /// Sets the function that is used to generate the rotation matrix.
  void set_rotation_matrix_creator(rotation_matrix_creator creator);
private:
  math::vector3 _rotation_center;

  const math::scalar _rotation_range;
  const camera _initial_camera;

  rotation_matrix_creator _rotation_creator;
};

/// Satisifies the \c animation::camera_stepper concept and implements
/// a rotation of the camera around one point and around two axes, described
/// by the angles phi and theta.
class dual_axis_rotation_around_point
{
public:
  /// \param center The center of the rotation
  /// \param phi_axis A normalized vector corresponding to the
  /// rotation axis of the phi angle
  /// \param theta_axis A normalized vector corresponding to the
  /// rotation axis of the theta angle
  /// \param cam The initial state of the camera
  /// \param rotation_range_phi_degree The range of the phi rotation in degree
  /// \param rotation_range_theta_degree The range of the theta rotation in degree
  dual_axis_rotation_around_point(const math::vector3& center,
                                   const math::vector3& phi_axis,
                                   const math::vector3& theta_axis,
                                   const camera& cam,
                                   math::scalar rotation_range_phi_degree = 360.0,
                                   math::scalar rotation_range_theta_degree = 360.0);

  /// Rotate the camera position and look-at vector
  /// \param frame_id The id of the frame of which the rotation state shall be adopted
  /// If \c frame_id = 0, the rotation angle is 0 rad, if \c frame_id = \c num_frames - 1
  /// the rotation angle is \c _rotation_range.
  /// \param num_frames The total number of frames
  /// \param cam the camera object that shall be rotated
  void operator()(std::size_t frame_id, std::size_t num_frames, camera& cam);

private:
  /// generate a matrix for the rotation around two axes.
  /// \param alpha_phi The phi angle in rad
  /// \param alpha_theta The theta angle in rad
  /// \param phi_axis The phi axis (must be normalized!)
  /// \param theta_axis The theta axis (must be normalized!)
  static math::matrix3x3 generate_rotation_matrix(math::scalar alpha_phi,
                                                  math::scalar alpha_theta,
                                                  const math::vector3& phi_axis,
                                                  const math::vector3& theta_axis);

  rotation_around_point _rotation;
};

/// A camera stepper that does not modify the camera at all
/// (useful for animations where the camera should stand still,
/// and quantity parameters shall be modified instead)
class constant_state
{
public:
  /// \c operator() to satisfy the \c camera_stepper concept. This camera stepper
  /// will not do anything.
  /// \param frame_id The id of the current frame
  /// \param num_frames The total number of frames
  /// \param cam The camera
  void operator()(std::size_t frame_id, std::size_t num_frames, camera& cam)
  {}
};

} // camera_movement

namespace frame_rendering {

/// Satisifies the \c animation::frame_renderer concept. An implementation
/// of a \c frame_renderer that renders images using the \c volumetric_integration,
/// i.e. an image is rendered by integrating through the reconstruction of a quantity.
class integrated_projection
{
public:
  /// \param ctx The OpenCL context that shall be used during the rendering process
  /// \param reconstructed_quantity The quantity that is reconstructed
  /// \param integration_depth The range of the integration
  /// \param tol The tolerance of the integration
  /// \param reconstructor The reconstruction engine that shall be used.
  integrated_projection(const qcl::device_context_ptr& ctx,
              const reconstruction_quantity::quantity& reconstructed_quantity,
              math::scalar integration_depth,
              const integration::tolerance& tol,
              reconstructing_data_crawler* reconstructor);

  /// Renders a frame
  /// \param cam The camera object describing position, look-at, resolution etc of
  /// the pixel screen
  /// \param frame_id The id (0 to \c num_frames - 1) of the current frame
  /// \param num_frames The total number of frames that shall be rendered
  /// \param out An array to hold the result. \c out will be properly initialized
  /// by this function, and does not need to be preinitialized.
  void operator()(const camera& cam,
                  std::size_t frame_id,
                  std::size_t num_frames,
                  util::multi_array<device_scalar>& out);

private:
  qcl::device_context_ptr _ctx;
  const reconstruction_quantity::quantity& _reconstructed_quantity;

  math::scalar _integration_range;
  integration::tolerance _tolerance;

  reconstructing_data_crawler* _reconstructor;
};

class multi_quantity_integrated_projection
{
public:
  using quantity_ptr = std::shared_ptr<reconstruction_quantity::quantity>;
  using quantity_generator = std::function
  <
    quantity_ptr (const camera& cam, std::size_t frame_id, std::size_t num_frames)
  >;

  multi_quantity_integrated_projection(const qcl::device_context_ptr& ctx,
                                       math::scalar integration_depth,
                                       const integration::tolerance& tol,
                                       reconstructing_data_crawler* reconstructor,
                                       const quantity_generator& create_quantity);



  void operator()(const camera& cam,
                  std::size_t frame_id,
                  std::size_t num_frames,
                  util::multi_array<device_scalar>& out);

private:
  qcl::device_context_ptr _ctx;
  math::scalar _integration_range;
  integration::tolerance _tolerance;
  reconstructing_data_crawler* _reconstructor;
  quantity_generator _create_quantity;
};


class single_quantity_generator
{
public:
  single_quantity_generator(const std::shared_ptr<reconstruction_quantity::quantity>& q);

  std::shared_ptr<reconstruction_quantity::quantity> operator()(const camera& cam,
                                                      std::size_t frame_id,
                                                      std::size_t num_frames) const;
private:
  std::shared_ptr<reconstruction_quantity::quantity> _quantity;
};




}
}

#endif

